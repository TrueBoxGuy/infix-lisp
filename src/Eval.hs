{-# LANGUAGE GeneralizedNewtypeDeriving #-}
module Eval where
--  
--  
--  import           Parse
--  import qualified Data.List                     as L
--  import           Data.Maybe                     ( fromMaybe )
--  import           Data.Bifunctor                 ( bimap
--                                                  , second
--                                                  )
--  
--  
--  data Value = VPrim Primitive | VFunction Function deriving (Show)
--  data Primitive = VNum Int | VStr String | VNil deriving (Show)
--  data Function = Builtin (Value -> Value -> IO Value) | Lambda String NExp String
--  
--  instance Show Function where
--    show (Builtin _        ) = "builtin"
--    show (Lambda a1 body a2) = unwords ["[", a1, show body, a2, "]"]
--  
--  newtype Env = Env [(String , Value)] deriving (Show, Semigroup, Monoid)
--  
--  
--  
--  runFunction :: Function -> Env -> Value -> Value -> IO Value
--  runFunction (Builtin f) _ arg1 arg2 = f arg1 arg2
--  runFunction (Lambda argName1 exp argName2) env arg1 arg2 =
--    evalExp (env <> Env [(argName1, arg1), (argName2, arg2)]) exp
--  
--  
--  
--  builtins :: [(String, Function)]
--  builtins =
--    [ ("+"    , Builtin builtinPlus)
--    , ("-"    , Builtin builtinMinus)
--    , ("print", Builtin builtinPrint)
--    ]
--   where
--    builtinPlus a1 a2 = pure $ VPrim $ case (a1, a2) of
--      (VPrim (VNum a), VPrim (VNum b)) -> VNum $ a + b
--      (VPrim (VStr a), VPrim (VStr b)) -> VStr $ a ++ b
--      _ -> illegalFunctionArguments "+" [a1, a2]
--  
--    builtinMinus a1 a2 = pure $ VPrim $ case (a1, a2) of
--      (VPrim (VNum a), VPrim (VNum b)) -> VNum $ a - b
--      _ -> illegalFunctionArguments "+" [a1, a2]
--  
--    builtinPrint _ a2 = case a2 of
--      VPrim (VStr s) -> putStrLn s >> pure (VPrim VNil)
--      _              -> illegalFunctionArguments "print" [a2]
--  
--  
--  
--  
--  illegalFunctionArguments :: String -> [Value] -> a
--  illegalFunctionArguments functionName args =
--    error $ functionName ++ " called with illegal arguments " ++ show args
--  
--  
--  evalExp :: Env -> NExp -> IO Value
--  evalExp env expression = case expression of
--    (ExpLit   lit          ) -> pure $ fromLiteral lit
--    (ExpIdent (Ident ident)) -> pure $ envLookup env ident
--    (ExpLambda (Ident argName1) body (Ident argName2)) ->
--      pure $ VFunction $ Lambda argName1 body argName2
--    (ExpInvocation arg1 (Ident name) arg2) -> case envLookup env name of
--      VFunction func -> do
--        res1 <- evalExp env arg1
--        res2 <- evalExp env arg2
--        runFunction func env res1 res2
--      _ -> error $ name ++ " is not a function"
--  
--  
--  
--  fromLiteral :: NLiteral -> Value
--  fromLiteral (StringLit s) = VPrim $ VStr s
--  fromLiteral (IntLit    n) = VPrim $ VNum n
--  
--  envLookup :: Env -> String -> Value
--  envLookup (Env env) name = maybe (VPrim VNil) snd
--    $ L.find (\(n, _) -> n == name) envWithBuiltins
--    where envWithBuiltins = env ++ map (second VFunction) builtins
--  
--  orNil :: Maybe Value -> Value
--  orNil = fromMaybe (VPrim VNil)
--  
--  
--  getName :: NIdent -> String
--  getName (Ident s) = s
